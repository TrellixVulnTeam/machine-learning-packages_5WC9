# -*- coding: utf-8 -*-
"""ddpm_csv_analysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
		https://colab.research.google.com/drive/1F0o63bWnJettOvWYmHyayQZpBF7XmUl1

# **CSV Analysis Tools**

# By Malek Ibrahim, 07.04.2022

The goal of this code is to develop various functions to extract data from csv files saved during training of DDPMs. Such files currently include validation loss over time, training loss over time, and DDRM PSNR on validation set mean + standard deviation.
"""

# Proprietary and Confidential
# Copyright 2003 - 2020 Stone Aerospace
# 3511 Caldwell Lane, Del Valle, TX 78617
# All rights reserved

# import modules/dependencies
import matplotlib
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import os
from scipy import stats
plt.rcParams['figure.figsize'] = [16, 8]

class Analyzer():
	def __init__(self, output_directory):
		self.out_dir = output_directory # where all of the csv files are stored

def loss_plotter(loss_data, labels, fig_num):
	"""Plots loss values obtained from a model training run.

	Args:
			loss_data: A list of 1D numpy arrays, or paths to a file for loading
			labels: A list of str objects corresponding to the items in loss_data
			
	Returns:
			A plot of the data with all loss plots and minimum loss locations labeled.
			
	"""
	# initialize figure
	plt.figure(fig_num)

	# loop over the list
	for i, item in enumerate(loss_data):
		# loads the file if it is a string
		if isinstance(item,str):
			data = np.array(pd.read_csv(item).iloc[:,-1])
		else:
			data = item
		
		x = np.arange(0, len(data)) + 1
		plt.plot(x, data, label=labels[i])
		
	plt.title('Loss Plot')
	plt.legend()
	plt.show()


def running_mean(data, window_size, window_step):
	"""Computes running mean of a data array.
				
	Args:
			data: A 1D array.
			
	Returns:
			The running mean of the data input, same shape as data.
	"""
	
	# initialize the running mean, iteration counter
	output = np.zeros_like(data)
	length = 0
	count = 0

	assert len(data) >= window_size, 'The window size over which the mean is computed must be smaller than the data length. Please reduce the window size and try again.'

	while len(data) - length >= window_size:
		output[window_step*count:window_step*(count+1)] = np.mean(data[window_step*count:window_size+window_step*count])
		length += window_step
		count += 1
	
	# take mean of remained of data array and set equal to remaining slice of running_mean
	output[window_step*(count-1)::] = np.mean(data[window_step*(count-1)::])

	return output


def plot_PSNR(mean_data, std_data, fig_num):
	"""Plots the mean PSNR data obtained during training along with standard deviation
				
	Args:
			mean_data: A 1D array or path to csv file, each point represents the mean PSNR calculated for a given batch of validation data
			std_data: A 1D array or path to csv file, each point represent the std of the PSNR calculated for a given batch of validation data
			fig_num: int, figure number to plot the data
			
	Returns:
			A plot of the mean and std for the PSNR data.
	"""

	# if necessary, load mean and standard deviation data
	if isinstance(mean_data,str):
		mdata = np.array(pd.read_csv(mean_data).iloc[:,-1])
	else:
		mdata = mean_data

	if isinstance(std_data,str):
		sdata = np.array(pd.read_csv(std_data).iloc[:,-1])
	else:
		sdata = std_data

	# initialize the figure
	plt.figure(fig_num)

	# plot the mean data
	p = plt.plot(mdata)
	plt.fill_between(np.arange(len(mdata)), mdata-sdata, mdata+sdata, color=p[0].get_color(), alpha=0.25)

	plt.title('DDRM PSNR Over Model Training')
	plt.show()


def plot_correlation(X_data, Y_data, fig_num):
	"""
	This function seeks to plot the potential correlation between two variables, X and Y.

	Args:
		X_data_path: str or 1D data vector, represents data to be plotted on x-axis
		X_data_path: str or 1D data vector, represents data to be plotted on y-axis

	Returns:
		m: float, slope of the correlation
		b: float, y-intercept of the correlation
		R2: coefficient of correlation

		Scatter plot with linear fit.

	"""
	# if necessary, load X and Y data
	if isinstance(X_data,str):
		X = np.array(pd.read_csv(X_data).iloc[:,-1])
	else:
		X = X_data
	
	if isinstance(Y_data,str):
		Y = np.array(pd.read_csv(Y_data).iloc[:,-1])
	else:
		Y = Y_data

	# obtain linear regression statistics
	m, b, R2, p_value, std_err = stats.linregress(X,Y)

	# create plot
	plt.figure(fig_num)
	plt.scatter(X,Y,label='Raw Data')
	plt.plot(X, m*X + b, label=f'Linear Fit, R2 = {R2:.03f}', color='r')
	plt.legend()
	plt.show()

	return m, b, R2